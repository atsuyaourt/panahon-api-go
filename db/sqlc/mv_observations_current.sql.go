// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: mv_observations_current.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestStationObservation = `-- name: GetLatestStationObservation :one
SELECT
  stn.name, stn.lat, stn.lon, stn.elevation, stn.address,
  obs.station_id, obs.rain, obs.temp, obs.rh, obs.wdir, obs.wspd, obs.srad, obs.mslp, obs.tn, obs.tx, obs.gust, obs.rain_accum, obs.tn_timestamp, obs.tx_timestamp, obs.gust_timestamp, obs.timestamp
FROM observations_station stn 
  JOIN mv_observations_current obs 
  ON stn.id = obs.station_id
WHERE stn.id = $1 LIMIT 1
`

type GetLatestStationObservationRow struct {
	Name                  string                `json:"name"`
	Lat                   pgtype.Float4         `json:"lat"`
	Lon                   pgtype.Float4         `json:"lon"`
	Elevation             pgtype.Float4         `json:"elevation"`
	Address               pgtype.Text           `json:"address"`
	MvObservationsCurrent MvObservationsCurrent `json:"mv_observations_current"`
}

func (q *Queries) GetLatestStationObservation(ctx context.Context, id int64) (GetLatestStationObservationRow, error) {
	row := q.db.QueryRow(ctx, getLatestStationObservation, id)
	var i GetLatestStationObservationRow
	err := row.Scan(
		&i.Name,
		&i.Lat,
		&i.Lon,
		&i.Elevation,
		&i.Address,
		&i.MvObservationsCurrent.StationID,
		&i.MvObservationsCurrent.Rain,
		&i.MvObservationsCurrent.Temp,
		&i.MvObservationsCurrent.Rh,
		&i.MvObservationsCurrent.Wdir,
		&i.MvObservationsCurrent.Wspd,
		&i.MvObservationsCurrent.Srad,
		&i.MvObservationsCurrent.Mslp,
		&i.MvObservationsCurrent.Tn,
		&i.MvObservationsCurrent.Tx,
		&i.MvObservationsCurrent.Gust,
		&i.MvObservationsCurrent.RainAccum,
		&i.MvObservationsCurrent.TnTimestamp,
		&i.MvObservationsCurrent.TxTimestamp,
		&i.MvObservationsCurrent.GustTimestamp,
		&i.MvObservationsCurrent.Timestamp,
	)
	return i, err
}

const listLatestObservations = `-- name: ListLatestObservations :many
SELECT
  stn.name, stn.lat, stn.lon, stn.elevation, stn.address,
  obs.station_id, obs.rain, obs.temp, obs.rh, obs.wdir, obs.wspd, obs.srad, obs.mslp, obs.tn, obs.tx, obs.gust, obs.rain_accum, obs.tn_timestamp, obs.tx_timestamp, obs.gust_timestamp, obs.timestamp
FROM observations_station stn 
  JOIN mv_observations_current obs 
  ON stn.id = obs.station_id
`

type ListLatestObservationsRow struct {
	Name                  string                `json:"name"`
	Lat                   pgtype.Float4         `json:"lat"`
	Lon                   pgtype.Float4         `json:"lon"`
	Elevation             pgtype.Float4         `json:"elevation"`
	Address               pgtype.Text           `json:"address"`
	MvObservationsCurrent MvObservationsCurrent `json:"mv_observations_current"`
}

func (q *Queries) ListLatestObservations(ctx context.Context) ([]ListLatestObservationsRow, error) {
	rows, err := q.db.Query(ctx, listLatestObservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLatestObservationsRow{}
	for rows.Next() {
		var i ListLatestObservationsRow
		if err := rows.Scan(
			&i.Name,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.Address,
			&i.MvObservationsCurrent.StationID,
			&i.MvObservationsCurrent.Rain,
			&i.MvObservationsCurrent.Temp,
			&i.MvObservationsCurrent.Rh,
			&i.MvObservationsCurrent.Wdir,
			&i.MvObservationsCurrent.Wspd,
			&i.MvObservationsCurrent.Srad,
			&i.MvObservationsCurrent.Mslp,
			&i.MvObservationsCurrent.Tn,
			&i.MvObservationsCurrent.Tx,
			&i.MvObservationsCurrent.Gust,
			&i.MvObservationsCurrent.RainAccum,
			&i.MvObservationsCurrent.TnTimestamp,
			&i.MvObservationsCurrent.TxTimestamp,
			&i.MvObservationsCurrent.GustTimestamp,
			&i.MvObservationsCurrent.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshMVCurrentObservations = `-- name: RefreshMVCurrentObservations :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_observations_current
`

func (q *Queries) RefreshMVCurrentObservations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshMVCurrentObservations)
	return err
}
